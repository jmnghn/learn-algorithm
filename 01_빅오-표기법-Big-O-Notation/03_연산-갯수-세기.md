## 연산 갯수 세기

'시간 재기'말고 그럼 뭐가 있을까?<br />
다시 말하지만, '시간 재기'는 너무 가변적이다.(그렇다고 '나쁜' 방법은 아니다. ^^;)<br />
<br />
컴퓨터가 수행해야 하는 작업의 수(counting operations)를 계산해 보자.<br />
<br />

<br />

### Couting Operations.

#### addUpTo - 1

```js
function addUpTo(n) {
  return (n * (n + 1)) / 2
}
```

<img width="800" src="https://user-images.githubusercontent.com/19165916/208287666-7dbf99da-4fd5-4a4a-8c05-4692ef2da40e.png"><br />

> _n_ 개의 크기에 관계없이 3개의 연산의 간단한 작업

#### addUpTo - 2

```js
function addUpTo(n) {
  let total = 0
  for (let i = 0; i <= n; i++) {
    total += i
  }
  return total
}
```

<img width="800" src="https://user-images.githubusercontent.com/19165916/208287755-e0d72f2d-aaf8-4065-9f02-a78832c931f4.png"><br />

> 5n + 2 개의 연산수<br /> > _n_ 개의 크기에 비례해 증가함

<br />

### Counting is hard!

우리가 무엇을 세느냐에 따라, <연산>의 수는 2n만큼 적거나 5n + 2만큼 높을 수 있다.<br />
(depending on what we count, the number of <operations> can be as low as 2n or as high as 5n + 2)<br />
그러나 정확한 숫자에 관계없이, <연산>의 수는 n에 대략 비례하여 증가한다.<br />
(but regardless of the exact number, the number of <operations> grows roughly proportionally with n)<br />
n개가 두 배가 되면, <연산>의 수 또한 대략 두 배가 될 것이다.<br />
(if n doubles, the number of <operations> will also roughly double)<br />

<br />

※ 모든 연산들을 다 세는 것은 힘들고, 또 정확한 갯수는 사실 별로 중요하지 않다.<br />
'전체적인 추세'가 중요하다. 5n + 2를 n으로 단순화해도 n이 커질 수록 실행 시간도 비례하게 늘어날 것이고, n 곱하기 2든, 곱하기 9든 10이든 1000이든 크게 중요하지 않은 것이다.<br />
'추세'가 그래프에 선이 n의 값과 비례한다는 것이다.
